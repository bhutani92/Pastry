import sys
from urllib3.connectionpool import xrange 

class Node(process):
    def setup(id:int):
        self.b = 4
        self.routingTable = [[None for x in xrange(2**b)] for x in xrange(32)]
        self.leafSet = []
        self.neighborhoodSet = []
        self.isNodeActive = True
        self.ipAddress = getRandomIPAddress()
        self.nodeKey = getNodeKey(self.ipAddress)
        self.coordinates = getCoordinates()
        self.routePath = []
        pass

    def getCoordinates():
        """
        Map the nodes in a 2D grid to determine the relative distance between
        the nodes
        """
        pass

    def getRandomIPAddress():
        """
        Get random IP Address for a particular node
        """
        pass

    def getNodeKey(ipAddress):
        """
        Get a 128-bit identifier by hashing the ip address
        """
        pass

    def getClosestNode(X):
        """
        Given a node X, determine the closest node based on the proximity metric
        """
        pass

    def addToRoutingTable(X):
        """
        Identity map the routing table
        """
        pass

    def updateRoutingTable(routingTable,leafSet,neighborhoodSet):
        """
        Update the routing table of the node X based on the closest nodes
        encountered present in the routePath
        """
        pass

    def sendJoinMessage(X):
        """
        Sends a join message on node arrival to find the nearest existing node Z
        whose id is numerically closest to X
        Returns:
        The set of nodes encountered on the path from A to Z
        """
        A = getClosestNode(X)
        send(("forward", "join", X), to= A)
        
        # Wait untill all states are received. Send own state to other nodes if required
        updateNeighbourSet(A, X)
        pass


    def updateNeighbourSet(A, X):
        """
        Initialize X's neighborhood set with A's neighborhood set
        """
        pass

    def updateLeafSet(Z, X):
        """
        Initialize X's leaf set with Z's leaf set
        """
        pass

    def getHopsCount(A, X):
        """
        This function is used to measure routing performance and returns the
        minimum number of hops between any two node A and X
        """
        pass

    def route(msg,keyid):
        """
        Causes Pastry to route the given message to the node with nodeId
        numerically closest to the key, among all live Pastry nodes
        """
        # Implement routing algorithm here. Will decide node/list of nodes to
        # forward the key (send('forward', msg, keyid))
        # If node current node itself is nearest node, do required steps
        pass
    
    def sendState(X):
        """
        Sending state to node X
        """
        send((routingTable, leafSet, neighborhoodSet), to= X)
        pass

    def receive(msg= ('forward', message, keyid)):
        """
        Callback function for handling forward messages
        """

        if (message == "join"):
            sendState(keyid)   

        route(message,keyid)
        pass

    def shl(A, B):
        """
        Returns:
        The length of the prefix shared among A and B
        """
        pass

    def nodeDelete(X):
        """
        Update Routing Table of every target node when node X exits
        """
        pass


    def receive(msg= (routingTable, leafSet, neighborhoodSet)):
        """
        Callback function for receiving state changes from node X
        """
        updateRoutingTable(routingTable, leafSet, neighborhoodSet)
        pass

    def repairLeafSet(X):
        """
        Repair the leaf set for node X to account for its deletion
        """
        pass

    def repairNeighborSet(X):
        """
        Repair the neighborhood set for node X to account for its deletion
        """
        pass

    def repairRoutingTable(X):
        """
        Repair the routing table entry for finding replacement node for node X
        """
        pass

    def run():
        output('Terminating')
        pass

def main():
    nprocs = 1
    ps = new(Node, num=nprocs)
    for p in ps:
        setup(p, (1, ))
    start(ps)
    pass
