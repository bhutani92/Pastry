# -*- generated by 1.0.12 -*-
import da
PatternExpr_261 = da.pat.TuplePattern([da.pat.ConstantPattern('getRandomNodes'), da.pat.FreePattern('numNodes')])
PatternExpr_268 = da.pat.FreePattern('X')
PatternExpr_329 = da.pat.TuplePattern([da.pat.ConstantPattern('NodeIsAlive'), da.pat.BoundPattern('_BoundPattern332_')])
PatternExpr_373 = da.pat.TuplePattern([da.pat.ConstantPattern('getClosestNeighbor'), da.pat.FreePattern('data')])
PatternExpr_380 = da.pat.FreePattern('X')
PatternExpr_475 = da.pat.ConstantPattern('ExitProcess')
PatternExpr_1757 = da.pat.TuplePattern([da.pat.ConstantPattern('acknowledgement'), da.pat.BoundPattern('_BoundPattern1760_')])
PatternExpr_1763 = da.pat.FreePattern('nextNode')
PatternExpr_1890 = da.pat.TuplePattern([da.pat.ConstantPattern('acknowledgement'), da.pat.BoundPattern('_BoundPattern1893_')])
PatternExpr_1896 = da.pat.BoundPattern('_BoundPattern1911_')
PatternExpr_2316 = da.pat.TuplePattern([da.pat.ConstantPattern('acknowledgement'), da.pat.BoundPattern('_BoundPattern2319_')])
PatternExpr_2322 = da.pat.FreePattern('nextNode')
PatternExpr_2534 = da.pat.TuplePattern([da.pat.ConstantPattern('LeafSet'), da.pat.FreePattern('xUpLeafSet'), da.pat.FreePattern('xDownLeafSet'), da.pat.BoundPattern('_BoundPattern2541_')])
PatternExpr_2544 = da.pat.BoundPattern('_BoundPattern2547_')
PatternExpr_2599 = da.pat.TuplePattern([da.pat.ConstantPattern('NodeIsAlive'), da.pat.BoundPattern('_BoundPattern2602_')])
PatternExpr_2605 = da.pat.BoundPattern('_BoundPattern2608_')
PatternExpr_2775 = da.pat.TuplePattern([da.pat.ConstantPattern('LeafSet'), da.pat.FreePattern('xUpLeafSet'), da.pat.FreePattern('xDownLeafSet'), da.pat.BoundPattern('_BoundPattern2780_')])
PatternExpr_2783 = da.pat.BoundPattern('_BoundPattern2786_')
PatternExpr_2835 = da.pat.TuplePattern([da.pat.ConstantPattern('NodeIsAlive'), da.pat.BoundPattern('_BoundPattern2838_')])
PatternExpr_2841 = da.pat.BoundPattern('_BoundPattern2844_')
PatternExpr_2995 = da.pat.TuplePattern([da.pat.ConstantPattern('NeighborhoodSet'), da.pat.FreePattern('xNeighborhoodSet'), da.pat.BoundPattern('_BoundPattern3000_')])
PatternExpr_3003 = da.pat.BoundPattern('_BoundPattern3006_')
PatternExpr_3043 = da.pat.TuplePattern([da.pat.ConstantPattern('NodeIsAlive'), da.pat.BoundPattern('_BoundPattern3046_')])
PatternExpr_3049 = da.pat.BoundPattern('_BoundPattern3052_')
PatternExpr_3181 = da.pat.TuplePattern([da.pat.ConstantPattern('RoutingTableEntry'), da.pat.FreePattern('xRTEntry'), da.pat.BoundPattern('_BoundPattern3186_')])
PatternExpr_3189 = da.pat.BoundPattern('_BoundPattern3192_')
PatternExpr_3229 = da.pat.TuplePattern([da.pat.ConstantPattern('NodeIsAlive'), da.pat.BoundPattern('_BoundPattern3232_')])
PatternExpr_3235 = da.pat.BoundPattern('_BoundPattern3238_')
PatternExpr_3271 = da.pat.TuplePattern([da.pat.ConstantPattern('getNeighborhoodSet'), da.pat.FreePattern('t')])
PatternExpr_3278 = da.pat.FreePattern('X')
PatternExpr_3294 = da.pat.TuplePattern([da.pat.ConstantPattern('getLeafset'), da.pat.FreePattern('t')])
PatternExpr_3301 = da.pat.FreePattern('X')
PatternExpr_3320 = da.pat.TuplePattern([da.pat.ConstantPattern('getRoutingTableEntry'), da.pat.FreePattern('row'), da.pat.FreePattern('col'), da.pat.FreePattern('t')])
PatternExpr_3331 = da.pat.FreePattern('X')
PatternExpr_3352 = da.pat.TuplePattern([da.pat.ConstantPattern('isNodeAlive'), da.pat.FreePattern('t')])
PatternExpr_3359 = da.pat.FreePattern('X')
PatternExpr_3372 = da.pat.TuplePattern([da.pat.ConstantPattern('stateTables'), da.pat.FreePattern('zRoutingTable'), da.pat.FreePattern('zNeighborhoodSet'), da.pat.FreePattern('obj'), da.pat.FreePattern('numHops')])
PatternExpr_3385 = da.pat.FreePattern('N')
PatternExpr_3480 = da.pat.TuplePattern([da.pat.ConstantPattern('resultingStateTables'), da.pat.FreePattern('downSet'), da.pat.FreePattern('upSet'), da.pat.FreePattern('xRoutingTable'), da.pat.FreePattern('xNeighborhoodSet'), da.pat.FreePattern('obj')])
PatternExpr_3495 = da.pat.FreePattern('X')
PatternExpr_3519 = da.pat.TuplePattern([da.pat.ConstantPattern('join'), da.pat.FreePattern('obj'), da.pat.FreePattern('numHops'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_3531 = da.pat.FreePattern('X')
PatternExpr_3570 = da.pat.TuplePattern([da.pat.ConstantPattern('lookup'), da.pat.FreePattern('obj'), da.pat.FreePattern('numHops'), da.pat.FreePattern('t1'), da.pat.FreePattern('t2'), da.pat.FreePattern('tDist')])
PatternExpr_3585 = da.pat.FreePattern('X')
PatternExpr_3606 = da.pat.TuplePattern([da.pat.ConstantPattern('getHopCount'), da.pat.FreePattern('src'), da.pat.FreePattern('dst')])
PatternExpr_3615 = da.pat.FreePattern('X')
PatternExpr_3638 = da.pat.TuplePattern([da.pat.ConstantPattern('acknowledgement'), da.pat.BoundPattern('_BoundPattern3641_')])
PatternExpr_3644 = da.pat.BoundPattern('_BoundPattern3647_')
PatternExpr_3678 = da.pat.TuplePattern([da.pat.ConstantPattern('done_lookup'), da.pat.FreePattern('numHops'), da.pat.BoundPattern('_BoundPattern3683_'), da.pat.FreePattern('tDist')])
PatternExpr_3773 = da.pat.TuplePattern([da.pat.ConstantPattern('closestNode'), da.pat.FreePattern('A'), da.pat.FreePattern('nid')])
PatternExpr_3846 = da.pat.TuplePattern([da.pat.ConstantPattern('done_join'), da.pat.FreePattern('upSet'), da.pat.FreePattern('downSet'), da.pat.FreePattern('maxHops'), da.pat.FreePattern('obj'), da.pat.FreePattern('tDist')])
PatternExpr_3888 = da.pat.TuplePattern([da.pat.ConstantPattern('stateTables'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_3916 = da.pat.TuplePattern([da.pat.ConstantPattern('stateTables'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern('o'), da.pat.FreePattern(None)])
PatternExpr_4044 = da.pat.TuplePattern([da.pat.ConstantPattern('NodeIsAlive'), da.pat.BoundPattern('_BoundPattern4047_')])
PatternExpr_4050 = da.pat.BoundPattern('_BoundPattern4053_')
PatternExpr_4080 = da.pat.ConstantPattern('ExitProcess')
_config_object = {}
import os
import sys
import random
import hashlib
import time
import math
import controller
from math import sqrt
from operator import itemgetter
from random import randint
INF = int(('9' * 50))

class BootStrapNode(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._BootStrapNodeReceivedEvent_1 = []
        self._BootStrapNodeReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_BootStrapNodeReceivedEvent_0', PatternExpr_261, sources=[PatternExpr_268], destinations=None, timestamps=None, record_history=None, handlers=[self._BootStrapNode_handler_260]), da.pat.EventPattern(da.pat.ReceivedEvent, '_BootStrapNodeReceivedEvent_1', PatternExpr_329, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_BootStrapNodeReceivedEvent_2', PatternExpr_373, sources=[PatternExpr_380], destinations=None, timestamps=None, record_history=None, handlers=[self._BootStrapNode_handler_372]), da.pat.EventPattern(da.pat.ReceivedEvent, '_BootStrapNodeReceivedEvent_3', PatternExpr_475, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, b, keySize, L, M, leafSetLen, tack, **rest_4108):
        super().setup(b=b, keySize=keySize, L=L, M=M, leafSetLen=leafSetLen, tack=tack, **rest_4108)
        self._state.b = b
        self._state.keySize = keySize
        self._state.L = L
        self._state.M = M
        self._state.leafSetLen = leafSetLen
        self._state.tack = tack
        self._state.nodes = []
        pass

    def run(self):
        '\n        This is the driver program for the BootStrap node. It simply waits for\n        some process to give the message ExitProcess. Upon receiving this\n        message, it terminates itself.\n        '
        print('BootStrap Node initiated')
        super()._label('_st_label_472', block=False)

        def ExistentialOpExpr_473():
            for (_, _, _ConstantPattern486_) in self._BootStrapNodeReceivedEvent_3:
                if (_ConstantPattern486_ == 'ExitProcess'):
                    if True:
                        return True
            return False
        _st_label_472 = 0
        while (_st_label_472 == 0):
            _st_label_472 += 1
            if ExistentialOpExpr_473():
                print('Bootstrap node is exiting')
                return
                _st_label_472 += 1
            else:
                super()._label('_st_label_472', block=True)
                _st_label_472 -= 1
        pass

    def getRelativeDistance(self, coord1, coord2):
        "\n        For scalar procimity metric, we use geographic distance of pastry nodes\n        for populating the neighborhood set.\n\n        Page number 9, section 2.5, paragraph 2 mentions:\n        'Pastry’s notion of network proximity is based on a scalar proximity\n        metric, such as the number of IP routing hops or geographic distance.'\n        "
        yDiff = (coord1[1] - coord2[1])
        xDiff = (coord1[0] - coord2[0])
        dist = sqrt(((yDiff ** 2) + (xDiff ** 2)))
        return dist

    def _BootStrapNode_handler_260(self, numNodes, X):
        '\n        The tester program contacts this node for information regarding any two\n        alive random nodes to initiate lookup between them and determine hop\n        count which is a correctness and performance metric mentioned in the\n        paper.\n        '
        if (numNodes > len(self._state.nodes)):
            print('Requested too many nodes. Not enough nodes in network')
            return
        objList = random.sample(self._state.nodes, numNodes)
        i = (- 1)
        while (i < (numNodes - 1)):
            i += 1
            o = objList[i]
            t = self.logical_clock()
            self.send(('isNodeAlive', t), to=o.nodeObj)
            super()._label('_st_label_326', block=False)

            def ExistentialOpExpr_327():
                for (_, _, (_ConstantPattern343_, _BoundPattern345_)) in self._BootStrapNodeReceivedEvent_1:
                    if (_ConstantPattern343_ == 'NodeIsAlive'):
                        if (_BoundPattern345_ == t):
                            if True:
                                return True
                return False
            _st_label_326 = 0
            self._timer_start()
            while (_st_label_326 == 0):
                _st_label_326 += 1
                if ExistentialOpExpr_327():
                    pass
                    _st_label_326 += 1
                elif self._timer_expired:
                    objList[i] = random.choice(self._state.nodes)
                    i -= 1
                    pass
                    _st_label_326 += 1
                else:
                    super()._label('_st_label_326', block=True, timeout=self._state.tack)
                    _st_label_326 -= 1
            else:
                if (_st_label_326 != 2):
                    continue
            if (_st_label_326 != 2):
                break
        self.send(('randomNodeList', objList), to=X)
    _BootStrapNode_handler_260._labels = None
    _BootStrapNode_handler_260._notlabels = None

    def _BootStrapNode_handler_372(self, data, X):
        "\n        Page number 7, section 2.4, paragraph 2 mentions:\n        'We assume the new node knows initially about a nearby Pastry node A,\n        according to the proximity metric, that is already part of the system.\n        Such a node can be located automatically, for instance, using “expanding\n        ring” IP multicast, or be obtained by the system administrator through\n        outside channels.'\n\n        Providing information about a Pastry node according to proximity metric\n        is the responsibility of this node.\n        "
        minDist = INF
        closestNode = None
        closestNodeId = ''
        if (data.nodeid in [o.nodeid for o in self._state.nodes]):
            self.send(('closestNode', data.nodeObj, data.nodeid), to=X)
            return
        for obj in self._state.nodes:
            dist = self.getRelativeDistance(obj.coordinates, data.coordinates)
            if (minDist > dist):
                minDist = dist
                closestNode = obj.nodeObj
                closestNodeId = obj.nodeid
        self._state.nodes.append(data)
        self.send(('closestNode', closestNode, closestNodeId), to=X)
        pass
    _BootStrapNode_handler_372._labels = None
    _BootStrapNode_handler_372._notlabels = None

class PastryNodeInfo():

    def __init__(self, obj, b, keySize):
        self.nodeObj = obj
        self.ipAddress = self.getRandomIPAddress()
        self.nodeid = self.getNodeKey(self.ipAddress, b, keySize)
        self.coordinates = self.getCoordinates()
        print('Pastry Node Info:', self, self.nodeid)

    def getCoordinates(self):
        "\n        Map the nodes in a 2D grid to determine the relative distance between\n        the nodes\n\n        Page number 13, section 3, 3rd paragraph mentions:\n        'Each Pastry node is assigned a location in a plane; coordinates in the\n        plane are randomly assigned in the range [0, 1000]. Nodes in the\n        Internet are not uniformly distributed in a Euclidean space; instead,\n        there is a strong clustering of nodes and the triangulation inequality\n        doesn’t always hold.'\n        "
        return [random.randint(0, 1000), random.randint(0, 1000)]

    def getRandomIPAddress(self):
        "\n        Get random IP Address for a particular node\n\n        Page number 3, section 2, paragraph 2 mentions:\n        'For instance, nodeIds could be generated by computing a cryptographic\n        hash of the node’s public key or its IP address.'\n        "
        return ((((((str(random.randint(0, 255)) + ':') + str(random.randint(0, 255))) + ':') + str(random.randint(0, 255))) + ':') + str(random.randint(0, 255)))

    def changeBase(self, num, base):
        '\n        Takes a number num in base 10 and converts it to base b\n\n        By default hexdigest is returned from cryptographic function used. We\n        convert the number in base 10 to a particular base b. This is useful if\n        we change the value of B which is by default 4.\n        '
        s = ''
        if (not num):
            return '0'
        while (num > 0):
            rem = (num % base)
            num = (num // base)
            s = (chr(((48 + rem) + (7 * (rem >= 10)))) + s)
        return s
        pass

    def getNodeKey(self, ip, b, keySize):
        "\n        Get a 128-bit identifier by hashing the ip address\n\n        Page number 3, section 2, paragraph 2 mentions:\n        'The nodeId is assigned randomly when a node joins the system. It is\n        assumed that nodeIds are generated such that the resulting set of\n        nodeIds is uniformly distributed in the 128-bit nodeId space.'\n        "
        ip = ip.encode('utf-8')
        dec = int(hashlib.md5(ip).hexdigest(), 16)
        n = self.changeBase(dec, (2 ** b))
        if (b == 2):
            n = (('0' * (64 - len(n))) + n)
        else:
            n = (('0' * (32 - len(n))) + n)
        n = n[0:int((keySize / b))]
        return n

class PastryNode(controller.Controllee, da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._PastryNodeReceivedEvent_0 = []
        self._PastryNodeReceivedEvent_1 = []
        self._PastryNodeReceivedEvent_2 = []
        self._PastryNodeReceivedEvent_3 = []
        self._PastryNodeReceivedEvent_4 = []
        self._PastryNodeReceivedEvent_5 = []
        self._PastryNodeReceivedEvent_6 = []
        self._PastryNodeReceivedEvent_7 = []
        self._PastryNodeReceivedEvent_8 = []
        self._PastryNodeReceivedEvent_9 = []
        self._PastryNodeReceivedEvent_10 = []
        self._PastryNodeReceivedEvent_20 = []
        self._PastryNodeReceivedEvent_21 = []
        self._PastryNodeReceivedEvent_22 = []
        self._PastryNodeReceivedEvent_23 = []
        self._PastryNodeReceivedEvent_24 = []
        self._PastryNodeReceivedEvent_25 = []
        self._PastryNodeReceivedEvent_26 = []
        self._PastryNodeReceivedEvent_27 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_0', PatternExpr_1757, sources=[PatternExpr_1763], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_1', PatternExpr_1890, sources=[PatternExpr_1896], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_2', PatternExpr_2316, sources=[PatternExpr_2322], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_3', PatternExpr_2534, sources=[PatternExpr_2544], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_4', PatternExpr_2599, sources=[PatternExpr_2605], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_5', PatternExpr_2775, sources=[PatternExpr_2783], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_6', PatternExpr_2835, sources=[PatternExpr_2841], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_7', PatternExpr_2995, sources=[PatternExpr_3003], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_8', PatternExpr_3043, sources=[PatternExpr_3049], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_9', PatternExpr_3181, sources=[PatternExpr_3189], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_10', PatternExpr_3229, sources=[PatternExpr_3235], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_11', PatternExpr_3271, sources=[PatternExpr_3278], destinations=None, timestamps=None, record_history=None, handlers=[self._PastryNode_handler_3270]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_12', PatternExpr_3294, sources=[PatternExpr_3301], destinations=None, timestamps=None, record_history=None, handlers=[self._PastryNode_handler_3293]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_13', PatternExpr_3320, sources=[PatternExpr_3331], destinations=None, timestamps=None, record_history=None, handlers=[self._PastryNode_handler_3319]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_14', PatternExpr_3352, sources=[PatternExpr_3359], destinations=None, timestamps=None, record_history=None, handlers=[self._PastryNode_handler_3351]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_15', PatternExpr_3372, sources=[PatternExpr_3385], destinations=None, timestamps=None, record_history=None, handlers=[self._PastryNode_handler_3371]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_16', PatternExpr_3480, sources=[PatternExpr_3495], destinations=None, timestamps=None, record_history=None, handlers=[self._PastryNode_handler_3479]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_17', PatternExpr_3519, sources=[PatternExpr_3531], destinations=None, timestamps=None, record_history=None, handlers=[self._PastryNode_handler_3518]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_18', PatternExpr_3570, sources=[PatternExpr_3585], destinations=None, timestamps=None, record_history=None, handlers=[self._PastryNode_handler_3569]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_19', PatternExpr_3606, sources=[PatternExpr_3615], destinations=None, timestamps=None, record_history=None, handlers=[self._PastryNode_handler_3605]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_20', PatternExpr_3638, sources=[PatternExpr_3644], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_21', PatternExpr_3678, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_22', PatternExpr_3773, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_23', PatternExpr_3846, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_24', PatternExpr_3888, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_25', PatternExpr_3916, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_26', PatternExpr_4044, sources=[PatternExpr_4050], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PastryNodeReceivedEvent_27', PatternExpr_4080, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, ctl, boot, b, keySize, L, M, leafSetLen, ti, tack, tn, tps, **rest_4108):
        super().setup(ctl=ctl, boot=boot, b=b, keySize=keySize, L=L, M=M, leafSetLen=leafSetLen, ti=ti, tack=tack, tn=tn, tps=tps, **rest_4108)
        self._state.ctl = ctl
        self._state.boot = boot
        self._state.b = b
        self._state.keySize = keySize
        self._state.L = L
        self._state.M = M
        self._state.leafSetLen = leafSetLen
        self._state.ti = ti
        self._state.tack = tack
        self._state.tn = tn
        self._state.tps = tps
        if (not (self._state.ctl == None)):
            super().setup(self._state.ctl)
        self._state.routingTable = [[None for x in range((2 ** self._state.b))] for x in range(int((self._state.keySize / self._state.b)))]
        self._state.upLeafSet = []
        self._state.downLeafSet = []
        self._state.neighborhoodSet = []
        self._state.nodeInfo = PastryNodeInfo(self._id, self._state.b, self._state.keySize)
        self.send(('getClosestNeighbor', self._state.nodeInfo), to=self._state.boot)
        pass

    def run(self):
        "\n        This is the driver program for the entire implementation.\n\n        Page number 7, section 2.4, paragraph 2 mentions\n        'When a new node arrives, it needs to initialize its state tables, and\n        then inform other nodes of its presence. We assume the new node knows\n        initially about a nearby Pastry node A, according to the proximity\n        metric, that is already part of the system. Such a node can be located\n        automatically, for instance, using “expanding ring” IP multicast, or be\n        obtained by the system administrator through outside channels. \n        Let us assume the new node’s nodeId is X. (The assignment of nodeIds is\n        applicationspecific; typically it is computed as the SHA-1 hash of its\n        IP address or its public key).  Node X then asks A to route a special\n        “join” message with the key equal to X. Like any message, Pastry routes\n        the join message to the existing node Z whose id is numerically closest\n        to X'\n        Also, page number 8, paragraph 2 mentions\n        'Finally, X transmits a copy of its resulting state to each of the nodes\n        found in its neighborhood set, leaf set, and routing table.\n        Finally, X transmits a copy of its resulting state to each of the nodes\n        found in its neighborhood set, leaf set, and routing table.'\n\n        After sending the resulting state, we send joinCompleted request so that\n        the parent() is aware that this node is ready to send and receive\n        messages. We then periodically check if any node needs repair in our\n        neighborhood set as mentioned in page number 9, first paragraph.\n\n        'For this purpose, a node attempts to contact each member of the\n        neighborhood set periodically to see if it is still alive.'\n\n        Whenever we receive a message ExitProcess, we stop whatever we are doing\n        and terminate the program.\n        "
        super()._label('_st_label_3770', block=False)
        nid = A = None

        def ExistentialOpExpr_3771():
            nonlocal nid, A
            for (_, _, (_ConstantPattern3790_, A, nid)) in self._PastryNodeReceivedEvent_22:
                if (_ConstantPattern3790_ == 'closestNode'):
                    if True:
                        return True
            return False
        _st_label_3770 = 0
        while (_st_label_3770 == 0):
            _st_label_3770 += 1
            if ExistentialOpExpr_3771():
                if (A == None):
                    print('I am first Node', self._state.nodeInfo.nodeid)
                    self.addMeInRoutingTable()
                    self.send('JoinCompleted', to=self.parent())
                elif (nid == self._state.nodeInfo.nodeid):
                    print('Node already present. Terminating')
                    return
                else:
                    self.addMeInRoutingTable()
                    self.send(('join', self._state.nodeInfo, 1, 0, 0, 0), to=A)
                    super()._label('_st_label_3843', block=False)
                    tDist = maxHops = upSet = obj = downSet = None

                    def ExistentialOpExpr_3844():
                        nonlocal tDist, maxHops, upSet, obj, downSet
                        for (_, _, (_ConstantPattern3869_, upSet, downSet, maxHops, obj, tDist)) in self._PastryNodeReceivedEvent_23:
                            if (_ConstantPattern3869_ == 'done_join'):
                                if True:
                                    return True
                        return False
                    _st_label_3843 = 0
                    self._timer_start()
                    while (_st_label_3843 == 0):
                        _st_label_3843 += 1
                        if ExistentialOpExpr_3844():
                            self.updateLeafSet(upSet, downSet, obj)
                            super()._label('_st_label_3885', block=False)
                            o = None

                            def ExistentialOpExpr_3886():
                                nonlocal o
                                for (_, _, (_ConstantPattern3905_, _, _, _, _)) in self._PastryNodeReceivedEvent_24:
                                    if (_ConstantPattern3905_ == 'stateTables'):
                                        if (len({o.nodeid for (_, _, (_ConstantPattern3934_, _, _, o, _)) in self._PastryNodeReceivedEvent_25 if (_ConstantPattern3934_ == 'stateTables')}) == maxHops):
                                            return True
                                return False
                            _st_label_3885 = 0
                            while (_st_label_3885 == 0):
                                _st_label_3885 += 1
                                if ExistentialOpExpr_3886():
                                    all_nodes = ((self._state.upLeafSet + self._state.downLeafSet) + self._state.neighborhoodSet)
                                    for routeTableRow in self._state.routingTable:
                                        for routeTableEntry in routeTableRow:
                                            if routeTableEntry:
                                                all_nodes.append(routeTableEntry)
                                    all_nodes = self.makeListUnique(all_nodes)
                                    for o in all_nodes:
                                        self.send(('resultingStateTables', self._state.downLeafSet, self._state.upLeafSet, self._state.routingTable, self._state.neighborhoodSet, self._state.nodeInfo), to=o.nodeObj)
                                    pass
                                    self.send('JoinCompleted', to=self.parent())
                                    _st_label_3885 += 1
                                else:
                                    super()._label('_st_label_3885', block=True)
                                    _st_label_3885 -= 1
                            _st_label_3843 += 1
                        elif self._timer_expired:
                            pass
                            _st_label_3843 += 1
                        else:
                            super()._label('_st_label_3843', block=True, timeout=self._state.ti)
                            _st_label_3843 -= 1
                _st_label_3770 += 1
            else:
                super()._label('_st_label_3770', block=True)
                _st_label_3770 -= 1
        super()._label('_st_label_4016', block=False)
        _st_label_4016 = 0
        self._timer_start()
        while (_st_label_4016 == 0):
            _st_label_4016 += 1
            if False:
                pass
                _st_label_4016 += 1
            elif self._timer_expired:
                pass
                _st_label_4016 += 1
            else:
                super()._label('_st_label_4016', block=True, timeout=self._state.tn)
                _st_label_4016 -= 1
        while True:
            t = self.logical_clock()
            for o in self._state.neighborhoodSet:
                self.send(('isNodeAlive', t), to=o.nodeObj)
                super()._label('_st_label_4041', block=False)

                def ExistentialOpExpr_4042():
                    for (_, (_, _, _BoundPattern4060_), (_ConstantPattern4064_, _BoundPattern4066_)) in self._PastryNodeReceivedEvent_26:
                        if (_BoundPattern4060_ == o.nodeObj):
                            if (_ConstantPattern4064_ == 'NodeIsAlive'):
                                if (_BoundPattern4066_ == t):
                                    if True:
                                        return True
                    return False
                _st_label_4041 = 0
                self._timer_start()
                while (_st_label_4041 == 0):
                    _st_label_4041 += 1
                    if ExistentialOpExpr_4042():
                        pass
                        _st_label_4041 += 1
                    elif self._timer_expired:
                        self.repairNeighborSet(o)
                        pass
                        _st_label_4041 += 1
                    else:
                        super()._label('_st_label_4041', block=True, timeout=self._state.tack)
                        _st_label_4041 -= 1
                else:
                    if (_st_label_4041 != 2):
                        continue
                if (_st_label_4041 != 2):
                    break
            super()._label('_st_label_4077', block=False)

            def ExistentialOpExpr_4078():
                for (_, _, _ConstantPattern4091_) in self._PastryNodeReceivedEvent_27:
                    if (_ConstantPattern4091_ == 'ExitProcess'):
                        if True:
                            return True
                return False
            _st_label_4077 = 0
            self._timer_start()
            while (_st_label_4077 == 0):
                _st_label_4077 += 1
                if ExistentialOpExpr_4078():
                    print('I am exiting: ', self._state.nodeInfo.nodeid)
                    return
                    pass
                    _st_label_4077 += 1
                elif self._timer_expired:
                    pass
                    _st_label_4077 += 1
                else:
                    super()._label('_st_label_4077', block=True, timeout=self._state.tn)
                    _st_label_4077 -= 1
            else:
                if (_st_label_4077 != 2):
                    continue
            if (_st_label_4077 != 2):
                break
        pass

    def updateRoutingTable(self, zRoutingTable, obj):
        "\n        Update the routing table of the current node based on the state\n        information obtained from other closest nodes present in the routePath\n\n        Page number 8, section 2.4, paragraph 5 mentios:\n        'Next, we consider the routing table, starting at row zero. We consider\n        the most general case, where the nodeIds of A and X share no common\n        prefix. Let Ai denote node A’s row of the routing table at level i. Note\n        that the entries in row zero of the routing table are independent of a\n        node’s nodeId. Thus, A0 contains appropriate values for X0. Other levels\n        of A’s routing table are of no use to X, since A’s and X’s ids share no\n        common prefix. However, appropriate values for X1 can be taken from B1,\n        where B is the first node encountered along the route from A to Z. To\n        see this, observe that entries in B1 and X1 share the same prefix,\n        because X and B have the same first digit in their nodeId.  Similarly, X\n        obtains appropriate entries for X2 from node C, the next node\n        encountered along the route from A to Z, and so on.'\n        "
        row2 = self.shl(obj.nodeid, self._state.nodeInfo.nodeid)
        for row in range(0, (row2 + 1)):
            col = (- 1)
            for routeTableEntry in zRoutingTable[row]:
                col += 1
                if (col == int(self._state.nodeInfo.nodeid[row], (2 ** self._state.b))):
                    self._state.routingTable[row][col] = self._state.nodeInfo
                elif (not (routeTableEntry == None)):
                    minDist = INF
                    if self._state.routingTable[row][col]:
                        minDist = self.getRelativeDistance(self._state.routingTable[row][col].coordinates, self._state.nodeInfo.coordinates)
                    if (self.getRelativeDistance(routeTableEntry.coordinates, self._state.nodeInfo.coordinates) < minDist):
                        self._state.routingTable[row][col] = routeTableEntry
        pass

    def addMeInRoutingTable(self):
        "\n        Identity map the routing table\n\n        The figure 1 in page number 4 presents:\n        'State of a hypothetical Pastry node with nodeId 10233102, b = 2, and l\n        = 8. All numbers are in base 4. The top row of the routing table is row\n        zero. The shaded cell in each row of the routing table shows the\n        corresponding digit of the present node’s nodeId. The nodeIds in each\n        entry have been split to show the common prefix with 10233102 - next\n        digit - rest of nodeId. The associated IP addresses are not shown.'\n        "
        i = (- 1)
        for routeTableRow in self._state.routingTable:
            i += 1
            self._state.routingTable[i][int(self._state.nodeInfo.nodeid[i], (2 ** self._state.b))] = self._state.nodeInfo
        pass

    def updateNeighborSet(self, neighborSet, obj):
        "\n        Update X's neighborhood set with A's neighborhood set\n\n        Page number 7, section 2.4, paragraph 5 mentions:\n        'Since node A is assumed to be in proximity to the new node X, A’s\n        neighborhood set to initialize X’s neighborhood set.'\n        "
        allNodeObjects = (self._state.neighborhoodSet + neighborSet)
        allNodeObjects.append(obj)
        allNodeObjects = self.makeListUnique(allNodeObjects)
        tuples = []
        for o in allNodeObjects:
            yDiff = (o.coordinates[1] - self._state.nodeInfo.coordinates[1])
            xDiff = (o.coordinates[0] - self._state.nodeInfo.coordinates[0])
            dist = sqrt(((yDiff ** 2) + (xDiff ** 2)))
            tuples.append((o, dist))
        tuples = sorted(tuples, key=(lambda t: t[1]))
        self._state.neighborhoodSet = [o for (o, dist) in tuples][:self._state.M]
        pass

    def makeListUnique(self, objSet):
        '\n        Make a list of PastryNodeInfo class objects unique based on nodeid as\n        nodeid is supposed to be unique.\n\n        This is a helper function which is used as python / distalgo uses pass\n        by value to send class objects as messages due to which usage of inbuild\n        set() and list() are futile. Hence, this method makes a list unique by\n        keeping only unique node ids in the list and returns it.\n\n        Returns: List of nodes with unique nodeids\n        '
        if (not objSet):
            return []
        all_tuples = [(o, o.nodeid) for o in objSet]
        all_nodes = self.unique_by_key(all_tuples, key=itemgetter(1))
        all_nodes = [o for (o, id) in all_nodes if (not (id == self._state.nodeInfo.nodeid))]
        return all_nodes

    def updateLeafSet(self, zUpSet, zDownSet, zobj):
        "\n        Initialize X's leaf set with Z's leaf set\n\n        Page number 7, section 2.4, paragraph 5 mentions:\n        'Moreover, Z has the closest existing nodeId to X, thus its leaf set is\n        the basis for X’s leaf set'\n        "
        all_nodes = (zUpSet + zDownSet)
        all_nodes.append(zobj)
        for o in all_nodes:
            if (o.nodeid < self._state.nodeInfo.nodeid):
                self._state.downLeafSet.append(o)
            elif (o.nodeid > self._state.nodeInfo.nodeid):
                self._state.upLeafSet.append(o)
        self._state.downLeafSet = self.makeListUnique(self._state.downLeafSet)
        self._state.downLeafSet = sorted(self._state.downLeafSet, key=(lambda o: o.nodeid))
        self._state.downLeafSet = self._state.downLeafSet[(- self._state.leafSetLen):]
        self._state.upLeafSet = self.makeListUnique(self._state.upLeafSet)
        self._state.upLeafSet = sorted(self._state.upLeafSet, key=(lambda o: o.nodeid))
        self._state.upLeafSet = self._state.upLeafSet[:self._state.leafSetLen]

    def getRelativeDistance(self, coord1, coord2):
        "\n        For scalar procimity metric, we use geographic distance of pastry nodes\n        for populating the neighborhood set.\n\n        Page number 9, section 2.5, paragraph 2 mentions:\n        'Pastry’s notion of network proximity is based on a scalar proximity\n        metric, such as the number of IP routing hops or geographic distance.'\n        "
        yDiff = (coord1[1] - coord2[1])
        xDiff = (coord1[0] - coord2[0])
        dist = sqrt(((yDiff ** 2) + (xDiff ** 2)))
        return dist

    def route(self, message, dstObj, numHops, tt, tDist):
        "\n        Causes Pastry to route the given message to the node with nodeId\n        numerically closest to the key, among all live Pastry nodes\n\n        Page number 5, section 2.2, Table 1 presents the entire core routing\n        algorithm:\n        '\n        (1) if (L−|L|/2 ≤ D ≤ L|L|/2) {\n        (2) // D is within range of our leaf set\n        (3) forward to Li, s.th. |D − Li| is minimal;\n        (4) } else {\n        (5) // use the routing table\n        (6) Let l = shl(D, A);\n        (7) if (RDl\n        l = null) {\n        (8) forward to RDl\n        l ;\n        (9) }\n        (10) else {\n        (11) // rare case\n        (12) forward to T ∈ L ∪ R ∪ M, s.th.\n        (13) shl(T,D) ≥ l,\n        (14) |T − D| < |A − D|\n        (15) }\n        (16) }\n        The entire pseudo code is translated to code to bolster the\n        implementation present in the paper.'\n        "
        minNode = None
        maxNode = None
        if ((self._state.downLeafSet == []) and (self._state.upLeafSet == [])):
            doneMsg = ('done_' + message)
            if (message == 'lookup'):
                self.send((doneMsg, numHops, tt, tDist), to=dstObj.nodeObj)
            else:
                self.send((doneMsg, self._state.upLeafSet, self._state.downLeafSet, numHops, self._state.nodeInfo, tDist), to=dstObj.nodeObj)
            return
        elif ((self._state.downLeafSet == []) and (not (self._state.upLeafSet == []))):
            minNode = self._state.nodeInfo
            maxNode = self._state.upLeafSet[(- 1)]
        elif ((not (self._state.downLeafSet == [])) and (self._state.upLeafSet == [])):
            minNode = self._state.downLeafSet[0]
            maxNode = self._state.nodeInfo
        else:
            minNode = self._state.downLeafSet[0]
            maxNode = self._state.upLeafSet[(- 1)]
        nextNode = self._id
        nextNodeInfo = self._state.nodeInfo
        minDist = abs((int(self._state.nodeInfo.nodeid, (2 ** self._state.b)) - int(dstObj.nodeid, (2 ** self._state.b))))
        if ((dstObj.nodeid >= minNode.nodeid) and (dstObj.nodeid <= maxNode.nodeid)):
            if (minNode == self._state.nodeInfo):
                for ulNode in self._state.upLeafSet:
                    if (abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(ulNode.nodeid, (2 ** self._state.b)))) < minDist):
                        minDist = abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(ulNode.nodeid, (2 ** self._state.b))))
                        nextNode = ulNode.nodeObj
                        nextNodeInfo = ulNode
            elif (maxNode == self._state.nodeInfo):
                for dlNode in self._state.downLeafSet:
                    if (abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(dlNode.nodeid, (2 ** self._state.b)))) < minDist):
                        minDist = abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(dlNode.nodeid, (2 ** self._state.b))))
                        nextNode = dlNode.nodeObj
                        nextNodeInfo = dlNode
            else:
                for ulNode in self._state.upLeafSet:
                    if (abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(ulNode.nodeid, (2 ** self._state.b)))) < minDist):
                        minDist = abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(ulNode.nodeid, (2 ** self._state.b))))
                        nextNode = ulNode.nodeObj
                        nextNodeInfo = ulNode
                for dlNode in self._state.downLeafSet:
                    if (abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(dlNode.nodeid, (2 ** self._state.b)))) < minDist):
                        minDist = abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(dlNode.nodeid, (2 ** self._state.b))))
                        nextNode = dlNode.nodeObj
                        nextNodeInfo = dlNode
            if (nextNode == self._id):
                doneMsg = ('done_' + message)
                if (message == 'lookup'):
                    self.send((doneMsg, numHops, tt, tDist), to=dstObj.nodeObj)
                else:
                    self.send((doneMsg, self._state.upLeafSet, self._state.downLeafSet, numHops, self._state.nodeInfo, tDist), to=dstObj.nodeObj)
                return
            else:
                t = self.logical_clock()
                dst = self.getRelativeDistance(self._state.nodeInfo.coordinates, nextNodeInfo.coordinates)
                self.send((message, dstObj, (numHops + 1), t, tt, (tDist + dst)), to=nextNode)
                if (message == 'lookup'):
                    super()._label('_st_label_1754', block=False)
                    nextNode = None

                    def ExistentialOpExpr_1755():
                        nonlocal nextNode
                        for (_, (_, _, nextNode), (_ConstantPattern1773_, _BoundPattern1775_)) in self._PastryNodeReceivedEvent_0:
                            if (_ConstantPattern1773_ == 'acknowledgement'):
                                if (_BoundPattern1775_ == t):
                                    if True:
                                        return True
                        return False
                    _st_label_1754 = 0
                    self._timer_start()
                    while (_st_label_1754 == 0):
                        _st_label_1754 += 1
                        if ExistentialOpExpr_1755():
                            return
                            pass
                            _st_label_1754 += 1
                        elif self._timer_expired:
                            self.repairLeafSet(nextNodeInfo)
                            self.route(message, dstObj, numHops, tt, tDist)
                            return
                            pass
                            _st_label_1754 += 1
                        else:
                            super()._label('_st_label_1754', block=True, timeout=self._state.tack)
                            _st_label_1754 -= 1
                return
        l = self.shl(dstObj.nodeid, self._state.nodeInfo.nodeid)
        nextNode = None
        nextNodeInfo = None
        if (not (self._state.routingTable[l][int(dstObj.nodeid[l], (2 ** self._state.b))] == None)):
            t = self.logical_clock()
            dst = self.getRelativeDistance(self._state.routingTable[l][int(dstObj.nodeid[l], (2 ** self._state.b))].coordinates, self._state.nodeInfo.coordinates)
            self.send((message, dstObj, (numHops + 1), t, tt, (tDist + dst)), to=self._state.routingTable[l][int(dstObj.nodeid[l], (2 ** self._state.b))].nodeObj)
            if (message == 'lookup'):
                super()._label('_st_label_1887', block=False)

                def ExistentialOpExpr_1888():
                    for (_, (_, _, _BoundPattern1918_), (_ConstantPattern1927_, _BoundPattern1929_)) in self._PastryNodeReceivedEvent_1:
                        if (_BoundPattern1918_ == self._state.routingTable[l][int(dstObj.nodeid[l], (2 ** self._state.b))].nodeObj):
                            if (_ConstantPattern1927_ == 'acknowledgement'):
                                if (_BoundPattern1929_ == t):
                                    if True:
                                        return True
                    return False
                _st_label_1887 = 0
                self._timer_start()
                while (_st_label_1887 == 0):
                    _st_label_1887 += 1
                    if ExistentialOpExpr_1888():
                        return
                        pass
                        _st_label_1887 += 1
                    elif self._timer_expired:
                        self.repairRoutingTable(self._state.routingTable[l][int(dstObj.nodeid[l], (2 ** self._state.b))], l, int(dstObj.nodeid[l], (2 ** self._state.b)))
                        self.route(message, dstObj, numHops, tt, tDist)
                        return
                        pass
                        _st_label_1887 += 1
                    else:
                        super()._label('_st_label_1887', block=True, timeout=self._state.tack)
                        _st_label_1887 -= 1
            pass
        else:
            leafFailed = False
            neighborFailed = False
            routingTableEntryFailed = False
            for ulNode in self._state.upLeafSet:
                if ((abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(ulNode.nodeid, (2 ** self._state.b)))) < abs((int(self._state.nodeInfo.nodeid, (2 ** self._state.b)) - int(dstObj.nodeid, (2 ** self._state.b))))) and (self.shl(dstObj.nodeid, ulNode.nodeid) >= self.shl(dstObj.nodeid, self._state.nodeInfo.nodeid))):
                    nextNode = ulNode.nodeObj
                    nextNodeInfo = ulNode
                    leafFailed = True
                    break
            if (nextNode == None):
                for dlNode in self._state.downLeafSet:
                    if ((abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(dlNode.nodeid, (2 ** self._state.b)))) < abs((int(self._state.nodeInfo.nodeid, (2 ** self._state.b)) - int(dstObj.nodeid, (2 ** self._state.b))))) and (self.shl(dstObj.nodeid, dlNode.nodeid) >= self.shl(dstObj.nodeid, self._state.nodeInfo.nodeid))):
                        nextNode = dlNode.nodeObj
                        nextNodeInfo = dlNode
                        leafFailed = True
                        break
            if (nextNode == None):
                for o in self._state.neighborhoodSet:
                    if ((abs((int(dstObj.nodeid, (2 ** self._state.b)) - int(o.nodeid, (2 ** self._state.b)))) < abs((int(self._state.nodeInfo.nodeid, (2 ** self._state.b)) - int(dstObj.nodeid, (2 ** self._state.b))))) and (self.shl(dstObj.nodeid, o.nodeid) >= self.shl(dstObj.nodeid, self._state.nodeInfo.nodeid))):
                        nextNode = o.nodeObj
                        nextNodeInfo = o
                        neighborFailed = True
                        break
            if (nextNode == None):
                failedRow = l
                failedCol = (- 1)
                for routeTableEntry in self._state.routingTable[l]:
                    failedCol += 1
                    if ((not (routeTableEntry == None)) and (abs((int(routeTableEntry.nodeid, (2 ** self._state.b)) - int(dstObj.nodeid, (2 ** self._state.b)))) < abs((int(self._state.nodeInfo.nodeid, (2 ** self._state.b)) - int(dstObj.nodeid, (2 ** self._state.b)))))):
                        nextNode = routeTableEntry.nodeObj
                        nextNodeInfo = routeTableEntry
                        routingTableEntryFailed = True
                        break
            if nextNode:
                t = self.logical_clock()
                dst = self.getRelativeDistance(self._state.nodeInfo.coordinates, nextNodeInfo.coordinates)
                self.send((message, dstObj, (numHops + 1), t, tt, (tDist + dst)), to=nextNode)
                if (message == 'lookup'):
                    super()._label('_st_label_2313', block=False)
                    nextNode = None

                    def ExistentialOpExpr_2314():
                        nonlocal nextNode
                        for (_, (_, _, nextNode), (_ConstantPattern2332_, _BoundPattern2334_)) in self._PastryNodeReceivedEvent_2:
                            if (_ConstantPattern2332_ == 'acknowledgement'):
                                if (_BoundPattern2334_ == t):
                                    if True:
                                        return True
                        return False
                    _st_label_2313 = 0
                    self._timer_start()
                    while (_st_label_2313 == 0):
                        _st_label_2313 += 1
                        if ExistentialOpExpr_2314():
                            return
                            pass
                            _st_label_2313 += 1
                        elif self._timer_expired:
                            if leafFailed:
                                self.repairLeafSet(nextNodeInfo)
                            elif neighborFailed:
                                self.repairNeighborSet(nextNodeInfo)
                            elif routingTableEntryFailed:
                                self.repairRoutingTable(nextNodeInfo, failedRow, failedCol)
                            self.route(message, dstObj, numHops, tt, tDist)
                            return
                            pass
                            _st_label_2313 += 1
                        else:
                            super()._label('_st_label_2313', block=True, timeout=self._state.tack)
                            _st_label_2313 -= 1
            else:
                doneMsg = ('done_' + message)
                if (message == 'lookup'):
                    self.send((doneMsg, numHops, tt, tDist), to=dstObj.nodeObj)
                else:
                    self.send((doneMsg, self._state.upLeafSet, self._state.downLeafSet, numHops, self._state.nodeInfo, tDist), to=dstObj.nodeObj)

    def sendState(self, numHops, X):
        "\n        Sending state to node X\n\n        Page number 7, section 2.4, paragraph 4 mentions:\n        'In response to receiving the “join” request, nodes A, Z, and all nodes\n        encountered on the path from A to Z send their state tables to X.'\n        "
        self.send(('stateTables', self._state.routingTable, self._state.neighborhoodSet, self._state.nodeInfo, numHops), to=X)
        pass

    def shl(self, A, B):
        "\n        Returns:\n        The length of the prefix shared among A and B\n\n        Page number 5, section 2.2 mentions:\n        'We begin by defining some notation.\n        Ri l: the entry in the routing table R at column i, 0 ≤ i < 2b and row\n              l, 0 ≤ l < 128/b.\n        Li: the i-th closest nodeId in the leaf set L, −|L|/2 ≤ i ≤ |L|/2, where\n            negative/positive indices indicate nodeIds smaller/larger than the\n            present nodeId, respectively.\n        Dl: the value of the l’s digit in the key D.\n        shl(A, B): the length of the prefix shared among A and B, in digits.'\n        "
        key_as_list = [str(A), str(B)]
        return len(os.path.commonprefix(key_as_list))

    def repairLeafSet(self, failedObj):
        "\n        Repair the leaf set for current node to account for a failed node X\n\n        Page number 8, section 2.4, paragraph 5 mentions:\n        'To replace a failed node in the leaf set, its neighbor in the nodeId\n        space contacts the live node with the largest index on the side of the\n        failed node, and asks that node for its leaf table.'\n        "
        if (failedObj.nodeid > self._state.nodeInfo.nodeid):
            self._state.upLeafSet = [o for o in self._state.upLeafSet if (not (o.nodeid == failedObj.nodeid))]
            beforeLength = len(self._state.upLeafSet)
            if (beforeLength == 0):
                print('No new nodes in the network. Cannot update my leaf set')
                return
            maxIndex = (- 1)
            for i in range(maxIndex, ((- beforeLength) - 1), (- 1)):
                next_largest_nodeObj = self._state.upLeafSet[i]
                t1 = self.logical_clock()
                self.send(('getLeafset', t1), to=next_largest_nodeObj.nodeObj)
                super()._label('_st_label_2531', block=False)
                xDownLeafSet = xUpLeafSet = None

                def ExistentialOpExpr_2532():
                    nonlocal xDownLeafSet, xUpLeafSet
                    for (_, (_, _, _BoundPattern2554_), (_ConstantPattern2558_, xUpLeafSet, xDownLeafSet, _BoundPattern2562_)) in self._PastryNodeReceivedEvent_3:
                        if (_BoundPattern2554_ == next_largest_nodeObj.nodeObj):
                            if (_ConstantPattern2558_ == 'LeafSet'):
                                if (_BoundPattern2562_ == t1):
                                    if True:
                                        return True
                    return False
                _st_label_2531 = 0
                self._timer_start()
                while (_st_label_2531 == 0):
                    _st_label_2531 += 1
                    if ExistentialOpExpr_2532():
                        full_leafsetObj = (xDownLeafSet + xUpLeafSet)
                        for leafObj in full_leafsetObj:
                            if (leafObj.nodeid > self._state.nodeInfo.nodeid):
                                t2 = self.logical_clock()
                                self.send(('isNodeAlive', t2), to=leafObj.nodeObj)
                                super()._label('_st_label_2596', block=False)

                                def ExistentialOpExpr_2597():
                                    for (_, (_, _, _BoundPattern2615_), (_ConstantPattern2619_, _BoundPattern2621_)) in self._PastryNodeReceivedEvent_4:
                                        if (_BoundPattern2615_ == leafObj.nodeObj):
                                            if (_ConstantPattern2619_ == 'NodeIsAlive'):
                                                if (_BoundPattern2621_ == t2):
                                                    if True:
                                                        return True
                                    return False
                                _st_label_2596 = 0
                                self._timer_start()
                                while (_st_label_2596 == 0):
                                    _st_label_2596 += 1
                                    if ExistentialOpExpr_2597():
                                        self._state.upLeafSet.append(leafObj)
                                        _st_label_2596 += 1
                                    elif self._timer_expired:
                                        pass
                                        _st_label_2596 += 1
                                    else:
                                        super()._label('_st_label_2596', block=True, timeout=self._state.tack)
                                        _st_label_2596 -= 1
                                else:
                                    if (_st_label_2596 != 2):
                                        continue
                                if (_st_label_2596 != 2):
                                    break
                        self._state.upLeafSet = self.makeListUnique(self._state.upLeafSet)
                        self._state.upLeafSet = sorted(self._state.upLeafSet, key=(lambda o: o.nodeid))
                        self._state.upLeafSet = self._state.upLeafSet[:self._state.leafSetLen]
                        afterLength = len(self._state.upLeafSet)
                        if (afterLength > beforeLength):
                            print('I am {}\nI found that node {} has failed so wanted to update my LefSet\nMy updated Up Leaf Set :- {}\nMy updated down Leaf Set :-  {}\n'.format(self._state.nodeInfo.nodeid, failedObj.nodeid, [o.nodeid for o in self._state.upLeafSet], [o.nodeid for o in self._state.downLeafSet]))
                            return
                        _st_label_2531 += 1
                    elif self._timer_expired:
                        pass
                        _st_label_2531 += 1
                    else:
                        super()._label('_st_label_2531', block=True, timeout=self._state.tack)
                        _st_label_2531 -= 1
                else:
                    if (_st_label_2531 != 2):
                        continue
                if (_st_label_2531 != 2):
                    break
        else:
            self._state.downLeafSet = [o for o in self._state.downLeafSet if (not (o.nodeid == failedObj.nodeid))]
            beforeLength = len(self._state.downLeafSet)
            if (beforeLength == 0):
                print('No new nodes in the network. Cannot update my leaf set')
            minIndex = 0
            for i in range(minIndex, beforeLength):
                next_smallest_nodeObj = self._state.downLeafSet[minIndex]
                t1 = self.logical_clock()
                self.send(('getLeafset', t1), to=next_smallest_nodeObj.nodeObj)
                super()._label('_st_label_2772', block=False)
                xDownLeafSet = xUpLeafSet = None

                def ExistentialOpExpr_2773():
                    nonlocal xDownLeafSet, xUpLeafSet
                    for (_, (_, _, _BoundPattern2793_), (_ConstantPattern2797_, xUpLeafSet, xDownLeafSet, _BoundPattern2801_)) in self._PastryNodeReceivedEvent_5:
                        if (_BoundPattern2793_ == next_smallest_nodeObj.nodeObj):
                            if (_ConstantPattern2797_ == 'LeafSet'):
                                if (_BoundPattern2801_ == t1):
                                    if True:
                                        return True
                    return False
                _st_label_2772 = 0
                self._timer_start()
                while (_st_label_2772 == 0):
                    _st_label_2772 += 1
                    if ExistentialOpExpr_2773():
                        full_leafsetObj = (xUpLeafSet + xDownLeafSet)
                        for leafObj in full_leafsetObj:
                            if (leafObj.nodeid < self._state.nodeInfo.nodeid):
                                t2 = self.logical_clock()
                                self.send(('isNodeAlive', t2), to=leafObj.nodeObj)
                                super()._label('_st_label_2832', block=False)

                                def ExistentialOpExpr_2833():
                                    for (_, (_, _, _BoundPattern2851_), (_ConstantPattern2855_, _BoundPattern2857_)) in self._PastryNodeReceivedEvent_6:
                                        if (_BoundPattern2851_ == leafObj.nodeObj):
                                            if (_ConstantPattern2855_ == 'NodeIsAlive'):
                                                if (_BoundPattern2857_ == t2):
                                                    if True:
                                                        return True
                                    return False
                                _st_label_2832 = 0
                                self._timer_start()
                                while (_st_label_2832 == 0):
                                    _st_label_2832 += 1
                                    if ExistentialOpExpr_2833():
                                        self._state.downLeafSet.append(leafObj)
                                        _st_label_2832 += 1
                                    elif self._timer_expired:
                                        pass
                                        _st_label_2832 += 1
                                    else:
                                        super()._label('_st_label_2832', block=True, timeout=self._state.tack)
                                        _st_label_2832 -= 1
                                else:
                                    if (_st_label_2832 != 2):
                                        continue
                                if (_st_label_2832 != 2):
                                    break
                        self._state.downLeafSet = self.makeListUnique(self._state.downLeafSet)
                        self._state.downLeafSet = sorted(self._state.downLeafSet, key=(lambda o: o.nodeid))
                        self._state.downLeafSet = self._state.downLeafSet[self._state.leafSetLen:]
                        afterLength = len(self._state.downLeafSet)
                        if (afterLength > beforeLength):
                            print('I am {}\nI found that node {} has failed so wanted to update my LefSet\nMy updated Up Leaf Set :- {}\nMy updated down Leaf Set :-  {}\n'.format(self._state.nodeInfo.nodeid, failedObj.nodeid, [o.nodeid for o in self._state.upLeafSet], [o.nodeid for o in self._state.downLeafSet]))
                            return
                        _st_label_2772 += 1
                    elif self._timer_expired:
                        pass
                        _st_label_2772 += 1
                    else:
                        super()._label('_st_label_2772', block=True, timeout=self._state.tack)
                        _st_label_2772 -= 1
                else:
                    if (_st_label_2772 != 2):
                        continue
                if (_st_label_2772 != 2):
                    break
        pass

    def repairNeighborSet(self, failedObj):
        "\n        Repair the neighborhood set for current node to account for a failed node X\n\n        Page number 8, section 2.4, paragraph 5, line number 4 mentions:\n        'If a member is not responding, the node asks other members for their\n        neighborhood tables, checks the distance of each of the newly discovered\n        nodes, and updates it own neighborhood set accordingly.'\n        "
        self._state.neighborhoodSet = [o for o in self._state.neighborhoodSet if (not (o.nodeid == failedObj.nodeid))]
        total_neighborsOfneighborsObj = []
        for neighborObj in self._state.neighborhoodSet:
            t1 = self.logical_clock()
            self.send(('getNeighborhoodSet', t1), to=neighborObj.nodeObj)
            super()._label('_st_label_2992', block=False)
            xNeighborhoodSet = None

            def ExistentialOpExpr_2993():
                nonlocal xNeighborhoodSet
                for (_, (_, _, _BoundPattern3013_), (_ConstantPattern3017_, xNeighborhoodSet, _BoundPattern3020_)) in self._PastryNodeReceivedEvent_7:
                    if (_BoundPattern3013_ == neighborObj.nodeObj):
                        if (_ConstantPattern3017_ == 'NeighborhoodSet'):
                            if (_BoundPattern3020_ == t1):
                                if True:
                                    return True
                return False
            _st_label_2992 = 0
            self._timer_start()
            while (_st_label_2992 == 0):
                _st_label_2992 += 1
                if ExistentialOpExpr_2993():
                    for neighborOfneighborObj in xNeighborhoodSet:
                        t2 = self.logical_clock()
                        self.send(('isNodeAlive', t2), to=neighborOfneighborObj.nodeObj)
                        super()._label('_st_label_3040', block=False)

                        def ExistentialOpExpr_3041():
                            for (_, (_, _, _BoundPattern3059_), (_ConstantPattern3063_, _BoundPattern3065_)) in self._PastryNodeReceivedEvent_8:
                                if (_BoundPattern3059_ == neighborOfneighborObj.nodeObj):
                                    if (_ConstantPattern3063_ == 'NodeIsAlive'):
                                        if (_BoundPattern3065_ == t2):
                                            if True:
                                                return True
                            return False
                        _st_label_3040 = 0
                        self._timer_start()
                        while (_st_label_3040 == 0):
                            _st_label_3040 += 1
                            if ExistentialOpExpr_3041():
                                total_neighborsOfneighborsObj.append(neighborOfneighborObj)
                                _st_label_3040 += 1
                            elif self._timer_expired:
                                pass
                                _st_label_3040 += 1
                            else:
                                super()._label('_st_label_3040', block=True, timeout=self._state.tack)
                                _st_label_3040 -= 1
                        else:
                            if (_st_label_3040 != 2):
                                continue
                        if (_st_label_3040 != 2):
                            break
                    _st_label_2992 += 1
                elif self._timer_expired:
                    pass
                    _st_label_2992 += 1
                else:
                    super()._label('_st_label_2992', block=True, timeout=self._state.tack)
                    _st_label_2992 -= 1
            else:
                if (_st_label_2992 != 2):
                    continue
            if (_st_label_2992 != 2):
                break
        total_neighborsOfneighborsObj = self.makeListUnique(total_neighborsOfneighborsObj)
        total_neighborsOfneighborsObj = [o for o in total_neighborsOfneighborsObj if (not (o.nodeid == failedObj.nodeid))]
        self.updateNeighborSet(total_neighborsOfneighborsObj, self._state.nodeInfo)

    def repairRoutingTable(self, failedObj, row, col):
        "\n        Function repairs routing table when a node 'X' with object 'failedObj' fails in routing table\n\n        Page number 8, section 2.4, paragraph 7 mentions:\n        'To repair a failed routing table entry R(l,d), a node contacts first\n        the node referred to by another entry R(l,i), i != d of the same row,\n        and asks for that node’s entry for R(l,d).  In the event that none of\n        the entries in row l have a pointer to a live node with the appropriate\n        prefix, the node next contacts an entry R(l+1, i), i != d, thereby\n        casting a wider net. This procedure is highly likely to eventually find\n        an appropriate node if one exists.'\n        "
        self._state.routingTable[row][col] = None
        return
        for r in range(row, len(self._state.routingTable)):
            for c in range(0, len(self._state.routingTable[r])):
                tempObj = self._state.routingTable[r][c]
                if ((not (c == col)) and (not (tempObj == None))):
                    t1 = self.logical_clock()
                    self.send(('getRoutingTableEntry', row, col, t1), to=tempObj.nodeObj)
                    super()._label('_st_label_3178', block=False)
                    xRTEntry = None

                    def ExistentialOpExpr_3179():
                        nonlocal xRTEntry
                        for (_, (_, _, _BoundPattern3199_), (_ConstantPattern3203_, xRTEntry, _BoundPattern3206_)) in self._PastryNodeReceivedEvent_9:
                            if (_BoundPattern3199_ == tempObj.nodeObj):
                                if (_ConstantPattern3203_ == 'RoutingTableEntry'):
                                    if (_BoundPattern3206_ == t1):
                                        if True:
                                            return True
                        return False
                    _st_label_3178 = 0
                    self._timer_start()
                    while (_st_label_3178 == 0):
                        _st_label_3178 += 1
                        if ExistentialOpExpr_3179():
                            if (not (xRTEntry == None)):
                                t2 = self.logical_clock()
                                self.send(('isNodeAlive', t2), to=xRTEntry.nodeObj)
                                super()._label('_st_label_3226', block=False)

                                def ExistentialOpExpr_3227():
                                    for (_, (_, _, _BoundPattern3245_), (_ConstantPattern3249_, _BoundPattern3251_)) in self._PastryNodeReceivedEvent_10:
                                        if (_BoundPattern3245_ == xRTEntry.nodeObj):
                                            if (_ConstantPattern3249_ == 'NodeIsAlive'):
                                                if (_BoundPattern3251_ == t2):
                                                    if True:
                                                        return True
                                    return False
                                _st_label_3226 = 0
                                self._timer_start()
                                while (_st_label_3226 == 0):
                                    _st_label_3226 += 1
                                    if ExistentialOpExpr_3227():
                                        self._state.routingTable[row][col] = xRTEntry
                                        return
                                        _st_label_3226 += 1
                                    elif self._timer_expired:
                                        pass
                                        _st_label_3226 += 1
                                    else:
                                        super()._label('_st_label_3226', block=True, timeout=self._state.tack)
                                        _st_label_3226 -= 1
                                else:
                                    if (_st_label_3226 != 2):
                                        continue
                                if (_st_label_3226 != 2):
                                    break
                            _st_label_3178 += 1
                        elif self._timer_expired:
                            pass
                            _st_label_3178 += 1
                        else:
                            super()._label('_st_label_3178', block=True, timeout=self._state.tack)
                            _st_label_3178 -= 1
                    else:
                        if (_st_label_3178 != 2):
                            continue
                    if (_st_label_3178 != 2):
                        break

    def unique_by_key(self, elements, key=None):
        '\n        This is a helper function to make a list of tuples unique based on a\n        single tuple parameter\n        '
        if (key is None):
            key = (lambda e: e)
        return {key(e1): e1 for e1 in elements}.values()

    def _PastryNode_handler_3270(self, t, X):
        '\n        As this is a distributed system, the state tables are requested by\n        passing appropriate messages.\n        '
        self.send(('NeighborhoodSet', self._state.neighborhoodSet, t), to=X)
    _PastryNode_handler_3270._labels = None
    _PastryNode_handler_3270._notlabels = None

    def _PastryNode_handler_3293(self, t, X):
        '\n        Message to get leaf set from X\n\n        As this is a distributed system, the state tables are requested by\n        passing appropriate messages.\n        '
        self.send(('LeafSet', self._state.upLeafSet, self._state.downLeafSet, t), to=X)
    _PastryNode_handler_3293._labels = None
    _PastryNode_handler_3293._notlabels = None

    def _PastryNode_handler_3319(self, row, col, t, X):
        "\n        Message to get routing table entry at failed (row,col) in other node's routing table\n\n        As this is a distributed system, the state tables are requested by\n        passing appropriate messages.\n        "
        self.send(('RoutingTableEntry', self._state.routingTable[row][col], t), to=X)
        pass
    _PastryNode_handler_3319._labels = None
    _PastryNode_handler_3319._notlabels = None

    def _PastryNode_handler_3351(self, t, X):
        '\n        Message to check if node is alive or not\n\n        As this is a distributed system, we can only check if the node is alive\n        by sending appropriate messages.\n        '
        self.send(('NodeIsAlive', t), to=X)
    _PastryNode_handler_3351._labels = None
    _PastryNode_handler_3351._notlabels = None

    def _PastryNode_handler_3371(self, zRoutingTable, zNeighborhoodSet, obj, numHops, N):
        "\n        Callback function for receiving state changes from node N\n        \n        Page number 7, section 2.4, paragraph 4 mentions:\n        'The new node X inspects this information, may request state from\n        additional nodes, and then initializes its own state tables, using a\n        procedure describe below. Finally, X informs any nodes that need to be\n        aware of its arrival. This procedure ensures that X initializes its\n        state with appropriate values, and that the state in all other affected\n        nodes is updated'\n        "
        if (numHops == 1):
            row = self.shl(obj.nodeid, self._state.nodeInfo.nodeid)
            for i in range(0, row):
                col = (- 1)
                for routeTableEntry in zRoutingTable[i]:
                    col += 1
                    if (col == int(self._state.nodeInfo.nodeid[i], (2 ** self._state.b))):
                        self._state.routingTable[i][col] = self._state.nodeInfo
                    elif (not (routeTableEntry == None)):
                        self._state.routingTable[i][col] = routeTableEntry
            self.updateNeighborSet(zNeighborhoodSet, obj)
        self.updateRoutingTable(zRoutingTable, obj)
        pass
    _PastryNode_handler_3371._labels = None
    _PastryNode_handler_3371._notlabels = None

    def _PastryNode_handler_3479(self, downSet, upSet, xRoutingTable, xNeighborhoodSet, obj, X):
        "\n        Page number 8, paragraph 2 mentions:\n        'Finally, X transmits a copy of its resulting state to each of the nodes\n        found in its neighborhood set, leaf set, and routing table. Those nodes\n        in turn update their own state based on the information received.'\n        "
        self.updateLeafSet(upSet, downSet, obj)
        self.updateNeighborSet(xNeighborhoodSet, obj)
        self.updateRoutingTable(xRoutingTable, obj)
        pass
    _PastryNode_handler_3479._labels = None
    _PastryNode_handler_3479._notlabels = None

    def _PastryNode_handler_3518(self, obj, numHops, X):
        "\n        Callback function for handling forward messages\n\n        Page number 7, section 2.4, paragraph 3 mentions:\n        'Node X then asks A to route a special “join” message with the key equal\n        to X. Like any message, Pastry routes the join message to the existing\n        node Z whose id is numerically closest to X.'\n        "
        dstNode = obj.nodeObj
        if (obj.nodeid == self._state.nodeInfo.nodeid):
            print('SENDING STATE TABLES TO MYSELF. OH MY GOD')
        self.sendState(numHops, obj.nodeObj)
        self.route('join', obj, numHops, 0, 0)
        pass
    _PastryNode_handler_3518._labels = None
    _PastryNode_handler_3518._notlabels = None

    def _PastryNode_handler_3569(self, obj, numHops, t1, t2, tDist, X):
        '\n        The core routing algorithm is used to route messages across the Pastry\n        network. To make sure this node is transmitting the information, we send\n        an acknowledgement to the sender. Sending acknowledgement was suggested\n        by Prof. Annie Liu to make sure node is alive.\n        '
        self.send(('acknowledgement', t1), to=X)
        self.route('lookup', obj, numHops, t2, tDist)
    _PastryNode_handler_3569._labels = None
    _PastryNode_handler_3569._notlabels = None

    def _PastryNode_handler_3605(self, src, dst, X):
        '\n        This is the initial phase of lookup where the tester program sends a\n        message getHopCount to start the lookup. The totalHops message is sent\n        once the lookup process is completed.\n        '
        t = self.logical_clock()
        self.send(('lookup', dst, 0, t, t, 0), to=src.nodeObj)
        super()._label('_st_label_3635', block=False)

        def ExistentialOpExpr_3636():
            for (_, (_, _, _BoundPattern3654_), (_ConstantPattern3658_, _BoundPattern3660_)) in self._PastryNodeReceivedEvent_20:
                if (_BoundPattern3654_ == src.nodeObj):
                    if (_ConstantPattern3658_ == 'acknowledgement'):
                        if (_BoundPattern3660_ == t):
                            if True:
                                return True
            return False
        _st_label_3635 = 0
        self._timer_start()
        while (_st_label_3635 == 0):
            _st_label_3635 += 1
            if ExistentialOpExpr_3636():
                pass
                _st_label_3635 += 1
            elif self._timer_expired:
                print('Source node with node id', src.nodeid, 'has failed. Terminating')
                return
                pass
                _st_label_3635 += 1
            else:
                super()._label('_st_label_3635', block=True, timeout=self._state.tack)
                _st_label_3635 -= 1
        super()._label('_st_label_3675', block=False)
        numHops = tDist = None

        def ExistentialOpExpr_3676():
            nonlocal numHops, tDist
            for (_, _, (_ConstantPattern3696_, numHops, _BoundPattern3699_, tDist)) in self._PastryNodeReceivedEvent_21:
                if (_ConstantPattern3696_ == 'done_lookup'):
                    if (_BoundPattern3699_ == t):
                        if True:
                            return True
            return False
        _st_label_3675 = 0
        self._timer_start()
        while (_st_label_3675 == 0):
            _st_label_3675 += 1
            if ExistentialOpExpr_3676():
                self.send(('totalHops', src, dst, numHops, tDist), to=X)
                _st_label_3675 += 1
            elif self._timer_expired:
                self.send(('totalHops', src, dst, (- 1), 0), to=X)
                print('Done lookup failed', (- 1), src.nodeid, self._state.nodeInfo.nodeid)
                _st_label_3675 += 1
            else:
                super()._label('_st_label_3675', block=True, timeout=self._state.tps)
                _st_label_3675 -= 1
    _PastryNode_handler_3605._labels = None
    _PastryNode_handler_3605._notlabels = None
